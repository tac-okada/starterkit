/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 158:
/***/ (function(module) {

/**
 * EvEmitter v2.1.1
 * Lil' event emitter
 * MIT License
 */

( function( global, factory ) {
  // universal module definition
  if (  true && module.exports ) {
    // CommonJS - Browserify, Webpack
    module.exports = factory();
  } else {
    // Browser globals
    global.EvEmitter = factory();
  }

}( typeof window != 'undefined' ? window : this, function() {

function EvEmitter() {}

let proto = EvEmitter.prototype;

proto.on = function( eventName, listener ) {
  if ( !eventName || !listener ) return this;

  // set events hash
  let events = this._events = this._events || {};
  // set listeners array
  let listeners = events[ eventName ] = events[ eventName ] || [];
  // only add once
  if ( !listeners.includes( listener ) ) {
    listeners.push( listener );
  }

  return this;
};

proto.once = function( eventName, listener ) {
  if ( !eventName || !listener ) return this;

  // add event
  this.on( eventName, listener );
  // set once flag
  // set onceEvents hash
  let onceEvents = this._onceEvents = this._onceEvents || {};
  // set onceListeners object
  let onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};
  // set flag
  onceListeners[ listener ] = true;

  return this;
};

proto.off = function( eventName, listener ) {
  let listeners = this._events && this._events[ eventName ];
  if ( !listeners || !listeners.length ) return this;

  let index = listeners.indexOf( listener );
  if ( index != -1 ) {
    listeners.splice( index, 1 );
  }

  return this;
};

proto.emitEvent = function( eventName, args ) {
  let listeners = this._events && this._events[ eventName ];
  if ( !listeners || !listeners.length ) return this;

  // copy over to avoid interference if .off() in listener
  listeners = listeners.slice( 0 );
  args = args || [];
  // once stuff
  let onceListeners = this._onceEvents && this._onceEvents[ eventName ];

  for ( let listener of listeners ) {
    let isOnce = onceListeners && onceListeners[ listener ];
    if ( isOnce ) {
      // remove listener
      // remove before trigger to prevent recursion
      this.off( eventName, listener );
      // unset once flag
      delete onceListeners[ listener ];
    }
    // trigger listener
    listener.apply( this, args );
  }

  return this;
};

proto.allOff = function() {
  delete this._events;
  delete this._onceEvents;
  return this;
};

return EvEmitter;

} ) );


/***/ }),

/***/ 564:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*!
 * imagesLoaded v5.0.0
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */

( function( window, factory ) {
  // universal module definition
  if (  true && module.exports ) {
    // CommonJS
    module.exports = factory( window, __webpack_require__(158) );
  } else {
    // browser global
    window.imagesLoaded = factory( window, window.EvEmitter );
  }

} )( typeof window !== 'undefined' ? window : this,
    function factory( window, EvEmitter ) {

let $ = window.jQuery;
let console = window.console;

// -------------------------- helpers -------------------------- //

// turn element or nodeList into an array
function makeArray( obj ) {
  // use object if already an array
  if ( Array.isArray( obj ) ) return obj;

  let isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';
  // convert nodeList to array
  if ( isArrayLike ) return [ ...obj ];

  // array of single index
  return [ obj ];
}

// -------------------------- imagesLoaded -------------------------- //

/**
 * @param {[Array, Element, NodeList, String]} elem
 * @param {[Object, Function]} options - if function, use as callback
 * @param {Function} onAlways - callback function
 * @returns {ImagesLoaded}
 */
function ImagesLoaded( elem, options, onAlways ) {
  // coerce ImagesLoaded() without new, to be new ImagesLoaded()
  if ( !( this instanceof ImagesLoaded ) ) {
    return new ImagesLoaded( elem, options, onAlways );
  }
  // use elem as selector string
  let queryElem = elem;
  if ( typeof elem == 'string' ) {
    queryElem = document.querySelectorAll( elem );
  }
  // bail if bad element
  if ( !queryElem ) {
    console.error(`Bad element for imagesLoaded ${queryElem || elem}`);
    return;
  }

  this.elements = makeArray( queryElem );
  this.options = {};
  // shift arguments if no options set
  if ( typeof options == 'function' ) {
    onAlways = options;
  } else {
    Object.assign( this.options, options );
  }

  if ( onAlways ) this.on( 'always', onAlways );

  this.getImages();
  // add jQuery Deferred object
  if ( $ ) this.jqDeferred = new $.Deferred();

  // HACK check async to allow time to bind listeners
  setTimeout( this.check.bind( this ) );
}

ImagesLoaded.prototype = Object.create( EvEmitter.prototype );

ImagesLoaded.prototype.getImages = function() {
  this.images = [];

  // filter & find items if we have an item selector
  this.elements.forEach( this.addElementImages, this );
};

const elementNodeTypes = [ 1, 9, 11 ];

/**
 * @param {Node} elem
 */
ImagesLoaded.prototype.addElementImages = function( elem ) {
  // filter siblings
  if ( elem.nodeName === 'IMG' ) {
    this.addImage( elem );
  }
  // get background image on element
  if ( this.options.background === true ) {
    this.addElementBackgroundImages( elem );
  }

  // find children
  // no non-element nodes, #143
  let { nodeType } = elem;
  if ( !nodeType || !elementNodeTypes.includes( nodeType ) ) return;

  let childImgs = elem.querySelectorAll('img');
  // concat childElems to filterFound array
  for ( let img of childImgs ) {
    this.addImage( img );
  }

  // get child background images
  if ( typeof this.options.background == 'string' ) {
    let children = elem.querySelectorAll( this.options.background );
    for ( let child of children ) {
      this.addElementBackgroundImages( child );
    }
  }
};

const reURL = /url\((['"])?(.*?)\1\)/gi;

ImagesLoaded.prototype.addElementBackgroundImages = function( elem ) {
  let style = getComputedStyle( elem );
  // Firefox returns null if in a hidden iframe https://bugzil.la/548397
  if ( !style ) return;

  // get url inside url("...")
  let matches = reURL.exec( style.backgroundImage );
  while ( matches !== null ) {
    let url = matches && matches[2];
    if ( url ) {
      this.addBackground( url, elem );
    }
    matches = reURL.exec( style.backgroundImage );
  }
};

/**
 * @param {Image} img
 */
ImagesLoaded.prototype.addImage = function( img ) {
  let loadingImage = new LoadingImage( img );
  this.images.push( loadingImage );
};

ImagesLoaded.prototype.addBackground = function( url, elem ) {
  let background = new Background( url, elem );
  this.images.push( background );
};

ImagesLoaded.prototype.check = function() {
  this.progressedCount = 0;
  this.hasAnyBroken = false;
  // complete if no images
  if ( !this.images.length ) {
    this.complete();
    return;
  }

  /* eslint-disable-next-line func-style */
  let onProgress = ( image, elem, message ) => {
    // HACK - Chrome triggers event before object properties have changed. #83
    setTimeout( () => {
      this.progress( image, elem, message );
    } );
  };

  this.images.forEach( function( loadingImage ) {
    loadingImage.once( 'progress', onProgress );
    loadingImage.check();
  } );
};

ImagesLoaded.prototype.progress = function( image, elem, message ) {
  this.progressedCount++;
  this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
  // progress event
  this.emitEvent( 'progress', [ this, image, elem ] );
  if ( this.jqDeferred && this.jqDeferred.notify ) {
    this.jqDeferred.notify( this, image );
  }
  // check if completed
  if ( this.progressedCount === this.images.length ) {
    this.complete();
  }

  if ( this.options.debug && console ) {
    console.log( `progress: ${message}`, image, elem );
  }
};

ImagesLoaded.prototype.complete = function() {
  let eventName = this.hasAnyBroken ? 'fail' : 'done';
  this.isComplete = true;
  this.emitEvent( eventName, [ this ] );
  this.emitEvent( 'always', [ this ] );
  if ( this.jqDeferred ) {
    let jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';
    this.jqDeferred[ jqMethod ]( this );
  }
};

// --------------------------  -------------------------- //

function LoadingImage( img ) {
  this.img = img;
}

LoadingImage.prototype = Object.create( EvEmitter.prototype );

LoadingImage.prototype.check = function() {
  // If complete is true and browser supports natural sizes,
  // try to check for image status manually.
  let isComplete = this.getIsImageComplete();
  if ( isComplete ) {
    // report based on naturalWidth
    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
    return;
  }

  // If none of the checks above matched, simulate loading on detached element.
  this.proxyImage = new Image();
  // add crossOrigin attribute. #204
  if ( this.img.crossOrigin ) {
    this.proxyImage.crossOrigin = this.img.crossOrigin;
  }
  this.proxyImage.addEventListener( 'load', this );
  this.proxyImage.addEventListener( 'error', this );
  // bind to image as well for Firefox. #191
  this.img.addEventListener( 'load', this );
  this.img.addEventListener( 'error', this );
  this.proxyImage.src = this.img.currentSrc || this.img.src;
};

LoadingImage.prototype.getIsImageComplete = function() {
  // check for non-zero, non-undefined naturalWidth
  // fixes Safari+InfiniteScroll+Masonry bug infinite-scroll#671
  return this.img.complete && this.img.naturalWidth;
};

LoadingImage.prototype.confirm = function( isLoaded, message ) {
  this.isLoaded = isLoaded;
  let { parentNode } = this.img;
  // emit progress with parent <picture> or self <img>
  let elem = parentNode.nodeName === 'PICTURE' ? parentNode : this.img;
  this.emitEvent( 'progress', [ this, elem, message ] );
};

// ----- events ----- //

// trigger specified handler for event type
LoadingImage.prototype.handleEvent = function( event ) {
  let method = 'on' + event.type;
  if ( this[ method ] ) {
    this[ method ]( event );
  }
};

LoadingImage.prototype.onload = function() {
  this.confirm( true, 'onload' );
  this.unbindEvents();
};

LoadingImage.prototype.onerror = function() {
  this.confirm( false, 'onerror' );
  this.unbindEvents();
};

LoadingImage.prototype.unbindEvents = function() {
  this.proxyImage.removeEventListener( 'load', this );
  this.proxyImage.removeEventListener( 'error', this );
  this.img.removeEventListener( 'load', this );
  this.img.removeEventListener( 'error', this );
};

// -------------------------- Background -------------------------- //

function Background( url, element ) {
  this.url = url;
  this.element = element;
  this.img = new Image();
}

// inherit LoadingImage prototype
Background.prototype = Object.create( LoadingImage.prototype );

Background.prototype.check = function() {
  this.img.addEventListener( 'load', this );
  this.img.addEventListener( 'error', this );
  this.img.src = this.url;
  // check if image is already complete
  let isComplete = this.getIsImageComplete();
  if ( isComplete ) {
    this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
    this.unbindEvents();
  }
};

Background.prototype.unbindEvents = function() {
  this.img.removeEventListener( 'load', this );
  this.img.removeEventListener( 'error', this );
};

Background.prototype.confirm = function( isLoaded, message ) {
  this.isLoaded = isLoaded;
  this.emitEvent( 'progress', [ this, this.element, message ] );
};

// -------------------------- jQuery -------------------------- //

ImagesLoaded.makeJQueryPlugin = function( jQuery ) {
  jQuery = jQuery || window.jQuery;
  if ( !jQuery ) return;

  // set local variable
  $ = jQuery;
  // $().imagesLoaded()
  $.fn.imagesLoaded = function( options, onAlways ) {
    let instance = new ImagesLoaded( this, options, onAlways );
    return instance.jqDeferred.promise( $( this ) );
  };
};
// try making plugin
ImagesLoaded.makeJQueryPlugin();

// --------------------------  -------------------------- //

return ImagesLoaded;

} );


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

// EXTERNAL MODULE: ./node_modules/imagesloaded/imagesloaded.js
var imagesloaded = __webpack_require__(564);
;// CONCATENATED MODULE: ./src/scripts/libs/youtubeAPI.js
var youtubeAPI_youtubeAPI = {
  initialize: function initialize() {
    var _this = this;
    /* youtubeAPI用グローバル関数 */
    window.onYouTubeIframeAPIReady = function () {
      if (!_this.youtubeData[_this.playerNum].playerReady) {
        _this.embedYoutube(_this.playerNum);
      }
    };

    //console.info(this)
    window.youtubeAPI = this;
  },
  /* Youtubeのscriptタグを設置済か否かの判定フラグ */
  flgYtTag: false,
  /* YouTubeプレーヤーを格納する配列 */
  ytPlayer: [],
  playerNum: 0,
  /*
  
    youtubeData  -----------------------------------------------
  
  */
  youtubeData: [
    /*{
      youtubeId: 'QOVglXRdo0Y',
      embedArea: 'player1',
      playerReady: false
    }*/
  ],
  /*
  
    setYoutube  -----------------------------------------------
  
  */
  setYoutube: function setYoutube() {
    //console.info(playerNum)
    if (this.flgYtTag) {
      onYouTubeIframeAPIReady();
    } else {
      var tag = document.createElement('script');
      tag.src = "https://www.youtube.com/iframe_api";
      var firstScriptTag = document.getElementsByTagName('script')[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
      this.flgYtTag = true;
    }
  },
  /*
  
    embedYoutube  -----------------------------------------------
  
  */
  embedYoutube: function embedYoutube(_num) {
    this.ytPlayer[_num] = new YT.Player(this.youtubeData[_num].embedArea,
    // width：プレーヤーの幅、height：プレーヤーの高さ、YouTubeのID
    {
      // width: 640,
      // height: 480,
      videoId: this.youtubeData[_num].youtubeId,
      playerVars: {
        // wmode：プレーヤーを背面に表示する
        // rel：再生終了後に関連動画を表示するかどうか設定
        // autoplay：自動再生するかどうか設定
        // showinfo：動画再生前にタイトルなどを表示するかどうか設定
        // loop：ループの設定
        // controls：コントロールバー表示設定 0:非表示、1:表示、2:動画再生後に表示
        // wmode: transparent,
        rel: 0,
        autoplay: 0,
        showinfo: 0,
        loop: 0,
        controls: 1
      },
      events: {
        // onReady：プレーヤーの準備ができたときに実行
        // onStateChange：プレーヤーの状態が変化したときに実行
        onReady: this.onPlayerReady(_num)
        // onStateChange: onPlayerStateChange
      }
    });
  },
  /*
  
    onPlayerReady  -----------------------------------------------
  
  */
  onPlayerReady: function onPlayerReady(_num) {
    this.youtubeData[_num].playerReady = true;
    //console.info(youtubeData,_num)
  }
};
;// CONCATENATED MODULE: ./src/scripts/libs/modal.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

youtubeAPI_youtubeAPI.initialize();
var Modal = /*#__PURE__*/function () {
  function Modal() {
    _classCallCheck(this, Modal);
    _defineProperty(this, "setBody", {
      fixed: function fixed(that) {
        //console.info(that);
        /* for andrid ver4.4 under */
        if (app.USER.os === 'android' && app.USER.osVersion < 4.4) {
          that.$body.addClass('absolute').css({
            'position': 'absolute',
            'width': '100%'
          });
        } else {
          that.$body.addClass('fixed').css({
            'width': '100%',
            'top': -1 * that.state.scrollPos
          });
        }
      },
      relative: function relative(that) {
        /* body position & scroll */
        that.$body.removeClass('fixed').css({
          'top': 'auto'
        });
        $('html, body').scrollTop(that.state.scrollPos);
      }
    });
    _defineProperty(this, "animationEvents", {
      open: function open(that, obj) {
        that.state.response = false;
        //console.info(that.proto.$obj,that.state.next)
        that.$bg.removeClass('hdn out').addClass('active in').on(app.animationEnd, function () {
          that.$bg.off(app.animationEnd);
          if (obj.bg_click) {
            /* パラメータ「bg_click」がtrueの場合 */
            that.$close_btn.removeClass('hdn out').addClass('active in').on(app.transitionEnd, function () {
              that.$close_btn.off(app.transitionEnd);
            });
          } else {/* パラメータ「bg_click」がfalseの場合 */
          }
          if (that.proto.$obj.hasClass('modal_iframe')) {
            /* iframeのスクロール位置をTOPに */
            that.proto.$obj.children('iframe').contents().find('html,body').scrollTop(0);
          }
          that.proto.$obj.removeClass('hdn out').addClass('in').on(app.animationEnd, function () {
            that.proto.$obj.off(app.animationEnd);
            that.state.response = true;
          });
          that.setCloseBtn.initialize(that, obj);
          /* resizeEvent */
          that.resizeEvent();
        });
      },
      close: function close(that, _obj) {
        //console.info(_obj)
        that.state.response = false;

        /* iOSでfixed要素のバグ（チラツキ）のためここに移動 */
        that.setBody.relative(that);
        that.$bg.removeClass('in').addClass('out').on(app.animationEnd, function () {
          that.$bg.off(app.animationEnd).removeClass('active out').addClass('hdn');
        });
        that.$close_btn.removeClass('in').addClass('out').on(app.transitionEnd, function () {
          that.$close_btn.off(app.transitionEnd).removeClass('active out').addClass('hdn');
        });
        _obj.target.removeClass('in').addClass('out').on(app.animationEnd, function () {
          _obj.target.off(app.animationEnd).removeClass('active out').removeAttr('style');
          that.state.response = true;
        });
      }
    });
    _defineProperty(this, "setCloseBtn", {
      initialize: function initialize(that, obj) {
        //console.info(_obj)
        /* パラメータ「bg_click」がfalseの場合 */
        if (!obj.bg_click) {
          $('#modal_bg, #modal_close').removeClass('js-modalClose');
        }
        that.$close = $('.js-modalClose');

        /* iframe内閉じるボタン */
        if (obj.target.hasClass('modal_iframe')) {
          that.$iframe = obj.target.children('iframe');
          that.$close = $('.js-modalClose').add('.js-modalClose', that.$iframe[0].contentWindow.document);
          //console.info($iframe,$close)
        }

        that.$close.off('click').on({
          'click': function click(e) {
            e.preventDefault();
            //console.info(this.state.response)
            if (that.state.response) {
              that.setCloseBtn.setupEvent(that, obj);
            }
          }
        });
      },
      setupEvent: function setupEvent(that, obj) {
        //console.info(_obj)
        var _grp = false;
        if (obj.grp_num !== 0) {
          _grp = true;
        }
        //console.info(_grp)
        that.animationEvents.close(that, obj);

        // Youtube stop
        if (obj.type === 'yt') {
          that.setPlayer({
            player: youtubeAPI_youtubeAPI.ytPlayer[obj.player_num - 1],
            event: 'stop'
          });
          //console.info(youtubeAPI.ytPlayer)
        }
      }
    });
    this.$window = $(window), this.$html = $('html'), this.$btn = $('.js-modalOpen'), this.$contents = $('.modal_contents'), this.$body = $('body'), this.iframepath = '', this.autoPlay = false, /* Youtube autoPlay */
    this.$close = '', this.$bg = '', this.$close_btn = '', this.$iframe = '', this.state = {
      response: false,
      width: 0,
      height: 0,
      scrollPos: 0
    }, this.proto = {
      contents: [],
      /* cts_txt */
      setdom: [],
      bg: '<div id="modal_bg" class="js-modalClose hdn"></div>',
      /* bg_txt */
      close: '<div id="modal_close" class="js-modalClose hdn"></div>',
      /* close_txt */
      num: [],
      /* modal_num */
      playerNum: 0,
      /* player_num */
      $obj: '' /* target */
    };
  }
  _createClass(Modal, [{
    key: "initialize",
    value: function initialize() {
      this.setTrigger();
      this.state.response = true;
      var _timer;
      var that = this;
      this.$window.on({
        'resize': function resize() {
          if (_timer !== false) {
            clearTimeout(_timer);
          }
          _timer = setTimeout(function () {
            that.resizeEvent();
          }, 10);
        }
      });
    }
  }, {
    key: "setHtml",
    value: function setHtml(_obj) {
      var _html = '';

      /* for Youtube */
      if (_obj.type === 'yt') {
        _html = '<div id="player' + _obj.player_num + '"></div>';

        /* for singleImage */
      } else if (_obj.type === 'img') {
        _html = '<img src="' + _obj.src + '" alt="" />';

        /* for iframe */
      } else if (_obj.type === 'iframe') {
        _html = '<iframe src="' + this.iframepath + _obj.src + '" frameborder="no"></iframe>';

        /* for freeContents */
      } else if (_obj.type === 'dom') {
        _html = $('.js-modal_dom').html();
        $('.js-modal_dom').remove();
      }

      //console.info(_html)
      return _html;
    }
  }, {
    key: "setPlayer",
    value: function setPlayer(_obj) {
      //console.info( _obj.event, _obj.player )
      if (_obj.event === 'play') {
        _obj.player.playVideo();
      } else if (_obj.event === 'stop') {
        /* ステータス / -1:未開始 / 0:終了 / 1:再生中 / 2:一時停止 / 3:バッファリング中 / 4:頭出し済み */
        if (_obj.player.getPlayerState() === ( false || 1 || 0 || 0)) {
          _obj.player.pauseVideo();
          _obj.player.seekTo(0);
        }
      }
    }
  }, {
    key: "openEvent",
    value: function openEvent(obj) {
      //console.info(_obj)
      /* for clickEvent */
      if (obj.event === 'click') {
        this.proto.$obj = $('.modal_' + obj.num);
        obj.target = this.proto.$obj;

        /* for otherEvent */
      } else if (obj.event === 'ready') {
        this.proto.$obj = obj.target;
      }

      /* for Youtube setAutoPlay */
      if (this.autoPlay) {
        this.setPlayer({
          player: youtubeAPI_youtubeAPI.ytPlayer[_obj.player_num - 1],
          event: 'play'
        });
      }
      if (!this.$body.hasClass('fixed')) {
        this.setBody.fixed(this);
      }

      /* for iOS iframeScroll */
      if (this.proto.$obj.hasClass('modal_iframe')) {
        if (app.USER.os === 'ios') {
          this.proto.$obj.css({
            'overflow-y': 'auto',
            '-webkit-overflow-scrolling': 'touch'
          });
        } else {
          this.proto.$obj.css({
            'overflow-y': 'hidden',
            '-webkit-overflow-scrolling': 'auto'
          });
        }
      }

      /* for firstOnly & not：modal_bg */
      if (!$('#modal_bg')[0]) {
        this.$body.append(this.proto.bg).prepend(this.proto.close);
        this.$bg = $('#modal_bg');
        this.$close_btn = $('#modal_close');
        if (app.USER.device === 'ipad' || app.USER.device === 'androidtablet' || app.USER.device === 'kindle') {
          // タブレット時のみ位置調整
          this.$close_btn.addClass('tb');
        }
      }
      this.proto.$obj.addClass('active');
      this.animationEvents.open(this, obj);
    }
  }, {
    key: "resizeEvent",
    value: function resizeEvent() {
      var $active = $('.modal_contents.active');
      var $active_yt = $('.modal_contents.active.modal_yt');
      this.state.width = $active.outerWidth();
      this.state.height = $active.outerHeight();

      /* iOS15用：ここから */
      var activeHeightDiff;
      //alert(window.navigator.userAgent.toLowerCase())
      if (app.USER.os === 'ios') {
        activeHeightDiff = 100;
      } else {
        activeHeightDiff = 70;
      }
      /* iOS15用：ここまで */

      // for modalActive
      if ($active[0]) {
        if ($active.hasClass('modal_yt')) {
          //console.info(app.mql)
          if (app.mql === 'pc') {
            /* PC時横幅固定 */
            this.state.width = Math.round(960);
          } else {
            this.state.width = app.win.width;
          }
          this.state.height = Math.round(this.state.width * 0.5625);
          if (this.state.height >= app.win.height) {
            this.state.height = app.win.height;
            this.state.width = app.win.height * 1.777777;
          }
          $active.css({
            'height': this.state.height,
            'width': this.state.width,
            'left': (app.win.width - this.state.width) / 2 + 'px',
            'top': (app.win.height - this.state.height) / 2 + 'px'
          });
        } else if ($active.hasClass('modal_iframe')) {
          $active.css({
            'height': app.win.height - activeHeightDiff,
            'top': '60px',
            'left': (app.win.width - this.state.width) / 2 + 'px'
          });
        } else {
          $active.css({
            'left': (app.win.width - this.state.width) / 2 + 'px',
            'top': (app.win.height - this.state.height) / 2 + 'px'
          });
        }
      }
    }
  }, {
    key: "setTrigger",
    value:
    /*
       setTrigger  -----------------------------------------------
     */
    function setTrigger() {
      var $btn = $('.js-modalOpen');
      var that = this;
      $btn.each(function (i) {
        var _num = Number($(this).attr('data-modal').split('__')[1]),
          _type = $(this).attr('data-modal').split('__')[2],
          _src = $(this).attr('data-modal').split('__')[3],
          _player_num = 0,
          _yt_id = '',
          _cts_txt_in = '',
          _flg_exist = false;

        //console.info(that)
        /* すでにモーダル作成済の場合dom生成しない */
        for (var x = 0; x < that.proto.num.length; x++) {
          if (that.proto.num[x] === _num) {
            _flg_exist = true;
            break;
          }
        }

        /* モーダル未作成の場合のみdom生成 */
        if (!_flg_exist) {
          that.proto.num.push(_num);
          //console.info(modal_num)
          if (_type === 'yt') {
            _yt_id = $(this).attr('data-modal').split('__')[3];
            _player_num = $(this).attr('data-ytnum');
            youtubeAPI_youtubeAPI.youtubeData.push({
              num: Number(_player_num),
              youtubeId: _yt_id,
              embedArea: 'player' + _player_num,
              playerReady: false
            });
          }
          _cts_txt_in = that.setHtml({
            num: _num,
            type: _type,
            src: _src,
            player_num: _player_num,
            yt_id: _yt_id
          });

          /* iframe個別埋め込みに変更 */
          that.proto.contents[_num - 1] = String() + '<div class="modal_contents modal_' + _num + ' modal_' + _type + '">' + _cts_txt_in + '</div>';
          that.proto.setdom[_num - 1] = false;
          //console.info(that.proto.contents[i])
        }
        //console.info(that.proto.setdom[_num - 1],i,_num)
        $(this).off().on({
          'click': function click(event) {
            //console.info(_num)
            event.preventDefault();
            that.state.scrollPos = window.pageYOffset;

            /* dom埋め込みここで */
            if (!that.proto.setdom[_num - 1]) {
              that.$body.prepend(that.proto.contents[_num - 1]);
              that.proto.setdom[_num - 1] = true;
            }

            /* youtube埋め込み */
            if (_type === 'yt') {
              youtubeAPI_youtubeAPI.playerNum = $(this).attr('data-ytnum') - 1;
              //console.info(youtubeAPI.playerNum,_player_num)
              //console.info(youtubeAPI.youtubeData[playerNum].playerReady)
              youtubeAPI_youtubeAPI.setYoutube();
            }
            if (that.state.response) {
              that.openEvent({
                target: $(this),
                event: 'click',
                num: _num,
                type: _type,
                player_num: _player_num,
                bg_click: true
              });
            }
          }
        });

        /* 最後に配列「youtubeData」を「num」順に並べ替え */
        if (i + 1 === $btn.length) {
          youtubeAPI_youtubeAPI.youtubeData.sort(function (a, b) {
            return a.num - b.num;
          });
        }
      });
    }

    /*
       setCloseBtn  -----------------------------------------------
     */
  }, {
    key: "open",
    value: function open(obj) {
      this.openEvent({
        target: obj.target,
        event: obj.event,
        num: obj.num,
        type: obj.type,
        player_num: obj.player_num,
        bg_click: obj.bgClick
      });
    }
  }]);
  return Modal;
}();
;
;// CONCATENATED MODULE: ./src/scripts/app.modal.js



/*

app.modal.js  -----------------------------------------------

*/
app.modal = function () {
  /* 画面リサイズ時に実行 */
  var resizeHandler = function resizeHandler() {
    //console.info(app.win.width,app.mql);
  };

  /* スクロール時に実行 */
  var scrollHandler = function scrollHandler() {
    //console.info(app.win.scrollTop,app.win.scrollBottom);
  };

  /* ページ読み込み時に実行 */
  var initialize = function initialize() {
    /* ここでブラウザイベントを有効にする */
    app.core.enableScroll();
    app.win.response = true;

    /* モーダルJS実行 */
    var modal = new Modal();
    modal.initialize();

    /* domのyoutubeへの置換 */
    $('#movie01').on('click', function (e) {
      e.preventDefault();
      youtubeAPI.youtubeData.push({
        num: $(this).attr('data-ytnum'),
        youtubeId: 't1rFmJMFdKw',
        embedArea: $(this).attr('id'),
        playerReady: false
      });
      //console.info(youtubeData,youtubeData.length)
      youtubeAPI.playerNum = $(this).attr('data-ytnum') - 1;
      youtubeAPI.setYoutube();
    });
  };
  return {
    resizeHandler: resizeHandler,
    scrollHandler: scrollHandler,
    initialize: initialize
  };
}();
})();

/******/ })()
;